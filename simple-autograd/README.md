# simple-autograd

Consider this mathematical expression:
```
y = (m * x) + b
```

Its computational graph might look like:
```
        y
        |
        +
       / \
      O   b
     /
    *
   / \
  m   x
```
Note the temporary node `O`. It is not specified in the expression, but rather generated by the graph program to ease the process of backtracking a node's graph.

With this in mind, create a `Variable` and `Constant` class such that they support evaluation and differentiation as illustrated below:
```python
>>> x = Variable(name='x')
>>> m = Variable(name='m')
>>> c = Constant('5')
>>>
>>> y = m * x * c
>>>
>>> y.evaluate(inputs={'m': 10, 'x': 15}) # calculate the value of y
750
>>>
>>> y.grad(respect_to='x', inputs={'m': 2, 'x': 5}) # calculate the derivative of y in respect to x
10
```

Chains should also be supported:
```python
>>> a = Variable(name='e')
>>> b = Variable(name='r')
>>> c = Constant(4)
>>> y = (a + b) ** c
>>>
>>> y.grad(respect_to='e', inputs={'e': 3, 'r': 2})
500
```

The following operations should be supported:
- Addition(+)
- Subtraction(-)
- Multiplication(\*)
- Division(/)
- Power(\*\*)

__Notes:__
- The power term `c` will always be a constant in any `a ^ c` for simplicity
- Constant folding is not required, but encouraged